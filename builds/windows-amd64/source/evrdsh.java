/* autogenerated by Processing revision 1304 on 2025-10-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.ArrayList;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class evrdsh extends PApplet {




// Constants

float GROUND_HEIGHT = 300;
int GROUND_COLOR = color(40,0,61);
int BACKGROUND_COLOR = color(71,121,196);
int OBSTACLE_COLOR = color(0,0,0,230);
int OBSTACLE_OUTLINE_COLOR = color(255,255,255,230);

float CUBE_SIZE = 100;
float CUBE_OFFSET = 400;
int CUBE_COLOR = color(255,255,0);
          
float MOVE_SPEED = 20;
float GRAVITY = 3.2f;
float JUMP_STRENGTH = 36;
float JUMP_MIDPOINT_FRAMES = JUMP_STRENGTH / GRAVITY; // frames from takeoff to jump midpoint, for a jump to the same elevation
float JUMP_TOTAL_FRAMES = JUMP_MIDPOINT_FRAMES * 2; // frames from takeoff to landing, for a jump to the same elevation
float ROTATE_PER_FRAME = PI / JUMP_TOTAL_FRAMES; // rotation per frame while jumping 
float JUMP_DIST = JUMP_MIDPOINT_FRAMES * 2 * MOVE_SPEED; // represents distance of jump to same elevation
float JUMP_REACH = JUMP_DIST + CUBE_SIZE; // the cube can jump on its rear end and land on its front end, so it can reach a body width further than jump distance
float JUMP_MIDPOINT_DIST = JUMP_DIST * 0.5f; // represents the x pos of the middle of the jump (where the cube is at its highest)
float JUMP_MIDPOINT_HEIGHT = JUMP_STRENGTH * JUMP_MIDPOINT_FRAMES - 0.5f * GRAVITY * JUMP_MIDPOINT_FRAMES * JUMP_MIDPOINT_FRAMES; // maximum height gained from jump 
float JUMP_LEEWAY = 20;
float SAFE_RANGE_W = 1000; // empty stretch at the start of every run
float OBSTACLE_UPDATE_OFFSET = 200; // how far the new obstacle spawns from the current camera position,
                                    // and how far left the obstacle can be before it is considered offscreen and removed.
float MIN_PLATFORM_H = CUBE_SIZE/2;

float CAMERA_SMOOTH = 0.1f; // 0..1 smoothing (higher = faster follow)
float CAMERA_MARGIN_TOP = 600; // px from bottom of view to top dead zone
float CAMERA_MARGIN_BOTTOM = 180; // px from bottom of view to bottom dead zone

int MIN_REST_TIME = PApplet.parseInt(CUBE_SIZE / MOVE_SPEED);
int MAX_REST_TIME = 50; // max number of frames the player has before elevation changes again 
float MIN_REST_LENGTH = 300;
float MAX_REST_LENGTH = 700; // (px) max distance that the player can do nothing (between jumps)
float MIN_INVERT_Y_DIFF = CUBE_SIZE;
float MAX_INVERT_Y_DIFF; // = height - GROUND_HEIGHT
int AIR_TIME_BEFORE_CRASH = 50; 



// Variables

boolean pressedSpace = false;
int score = 0;
int normalHighscore = 0; 
int invertHighscore = 0; 

float cubeX = CUBE_OFFSET + CUBE_SIZE/2;
float cubeY = CUBE_SIZE/2;
float vx = MOVE_SPEED;
float vy = 0;
float prevY = 0;
boolean onSurface = true;
float cubeAngle = 0;

float cameraX = 0;
float cameraY = CUBE_SIZE/2;
float cameraSpeed = MOVE_SPEED;   
float groundX = 0;

ArrayList<Obstacle> obstacles = new ArrayList<>(); // list of all obstacles generated this run
float difficulty = 0; // ramping difficulty as the run goes on (to be added)
float lastPlatformRight = 100;
float lastPlatformLeft = 0;
float lastPlatformGravDir = 1;  // {-1,1}: 1 for normal gravity, -1 for inverted

float gravDir = 1;  // {-1,1}: 1 for normal gravity, -1 for inverted

// these coords are of the cube's center
// used to generate trajectory for cube and spawn platforms from trajectory
float nextJumpX = cubeX + SAFE_RANGE_W;
float nextJumpY = CUBE_SIZE/2;
float nextLandX = 0;
float nextLandY = CUBE_SIZE/2;
float thisJumpX = 0;
float thisJumpY = 0; 
float thisLandX = cubeX;
float thisLandY = CUBE_SIZE/2; 

enum Screen {Menu, Normal, Invert, Crash};
Screen screen = Screen.Menu;
enum Game {Normal, Invert};
Game lastGame;

public void setup() {
  /* size commented out by preprocessor */;
  layers.add(layer1);
  layers.add(layer2);
  layers.add(layer3);
  layers.add(layer4);
  layers.add(layer5);
  layers.add(layer6);
  background(255);
  
  MAX_INVERT_Y_DIFF = height - GROUND_HEIGHT;
  
}

public void draw() {

  // Clear onscreen visuals
  background(255);
  
  if (screen == Screen.Menu) {
    drawMenu();
  }
  else if (screen == Screen.Normal) {
    drawNormalGame();
  }
  else if (screen == Screen.Invert) {
    drawInvertGame();
  }
  else if (screen == Screen.Crash) {
    drawCrash();
  }
  
}

public void updateScore() {
  score = round(cubeX/500)*10;
  if (screen == Screen.Normal && score > normalHighscore) normalHighscore = score; // real time highscore update
  else if (screen == Screen.Invert && score > invertHighscore) invertHighscore = score;
}

public void drawUI() {
  pushMatrix();
  pushStyle();
  
  translate(0, height);
  scale(1,-1);
  
  fill(255);
  textSize(50);
  textAlign(LEFT,BOTTOM);
  text("SCORE " + score, 40, 100);
  text("HIGHSCORE " + ((screen == Screen.Normal) ? normalHighscore : invertHighscore), 40, 170);
  
  // Draw tutorial if the player hasn't pressed space yet
  if (!pressedSpace) {
    fill(255);
    textSize(100);
    textAlign(LEFT,BOTTOM);
    text("press SPACE to jump", 540, 400);
  }
  popMatrix();
  popStyle();
}

public void updateCamera() {
  cameraX += cameraSpeed; // horizontal camera follows cube instantly
  
  // vertical camera follows cube smoothly
  // only follows when cube leaves vertical deadzone
  float minYDiff = 50;
  float targetY = cameraY;
  float cubeTop = cubeY + CUBE_SIZE/2;
  float cubeBottom = cubeY - CUBE_SIZE/2;
  
  if (cubeTop > cameraY + CAMERA_MARGIN_TOP) {
    targetY = cubeTop - CAMERA_MARGIN_TOP;
  }

  else if (cubeBottom < cameraY + CAMERA_MARGIN_BOTTOM) {
    targetY = cubeY - CAMERA_MARGIN_BOTTOM;  
  }

  if (Math.abs(targetY-cameraY) > minYDiff) cameraY += (targetY - cameraY) * CAMERA_SMOOTH; // simple exponential lerp
  
  if (lastGame == Game.Normal && cameraY < 0) cameraY = 0; // don't show world below y=0 in Normal gamemode
}

public void generateObstacles() {

  if (cameraX+width+OBSTACLE_UPDATE_OFFSET < nextJumpX-CUBE_SIZE/2) {
    return;
  }
  if (obstacles.isEmpty()) {
    lastPlatformRight = cubeX + SAFE_RANGE_W + CUBE_SIZE/2;
    lastPlatformLeft = 0;
  }
  thisJumpX = nextJumpX;
  thisJumpY = nextJumpY;
  thisLandX = nextLandX;
  thisLandY = nextLandY;
    
  // randomize x of next jump, y of next jump is equal to current y pos
  nextJumpX = thisLandX + random(MIN_REST_LENGTH, MAX_REST_LENGTH);
  nextJumpY = thisLandY;

  float lowerBound = 0;
  float upperBound = 0;
  if (screen == Screen.Normal) {

    // randomize an y for nextLandY, ranging from 0 (ground level) to the max of a jump from the current position
    // based on the trajectory of a jump from thisJumpX, and the provided y, calculate nextLandX
    // only consider the second half of the jump (when the cube falls back down) when computing x,
    // since any land on the first half is not possible without collision.
    // this algorithm is made to ensure there is a possible for every situation, and no irrational jumps are generated. 
    float thisJumpMidpointX = thisJumpX + JUMP_MIDPOINT_DIST;
    float nextJumpMidpointX = nextJumpX + JUMP_MIDPOINT_DIST;
    float thisJumpMaxY = thisJumpY + JUMP_MIDPOINT_HEIGHT;
    float nextJumpMaxY = nextJumpY + JUMP_MIDPOINT_HEIGHT;
    
    nextLandY = random(0, nextJumpMaxY) - JUMP_LEEWAY;
    if (nextLandY < MIN_PLATFORM_H + CUBE_SIZE/2) nextLandY = CUBE_SIZE/2;
    nextLandX = landingXForTargetY(nextJumpX, nextJumpY, nextLandY);

    // generate platform that can support this land and next jump 
    // compared to an adjacent platform (the previous or the next):
      // if the current platform is at a lower elevation: it can extend to reach the boundary of the adjacent platform
      // if the current platform is at a higher elevation: it can only extend to the x pos of the middle of the corresponding jump trajectory
    if (thisLandY < thisJumpY) {
      lowerBound = lastPlatformRight;
    }
    else {
      lowerBound = max(thisJumpMidpointX, lastPlatformRight);
    }
    if (nextJumpY < nextLandY) {
      upperBound = nextLandX - CUBE_SIZE/2;
    } 
    else {
      upperBound = nextJumpMidpointX;
    } 
  }
  else if (screen == Screen.Invert) {

    float nextJumpYDiff = random(MIN_INVERT_Y_DIFF, MAX_INVERT_Y_DIFF); 
    nextLandY = (lastPlatformGravDir == 1) ? nextJumpY-nextJumpYDiff : nextJumpY+nextJumpYDiff;  // Same gravity direction as 2 platforms ago 
    nextLandX = landingXForTargetYInvert(nextJumpX, nextJumpY, nextLandY);

    lowerBound = lastPlatformRight;
    upperBound = nextJumpX + CUBE_SIZE/2;
  }

  float lowerMin = lowerBound; 
  float lowerMax = thisLandX;
  float upperMin = nextJumpX; 
  float upperMax = upperBound;

  float lowerX = random(lowerMin,lowerMax);
  float upperX = random(upperMin,upperMax);
  float obX = lowerX;
  float obW = upperX - lowerX;
  float obY = 0;
  float obH = 0;
  if (screen == Screen.Normal) {
    obY = 0;
    obH = thisLandY - CUBE_SIZE/2;
  }
  else if (screen == Screen.Invert) {
    obY = (lastPlatformGravDir == 1) ? thisLandY + CUBE_SIZE/2 : thisLandY - CUBE_SIZE/2;
    obH = height*5; // simulating infinity
  }
  
  // add to list of generations
  Obstacle o = null;
  if (screen == Screen.Normal) {
    o = new Obstacle(obX, obY, obW, obH, 1, Type.Platform);
    obstacles.add(o);
  }
  else if (screen == Screen.Invert) {
    if (lastPlatformGravDir == 1) o = new Obstacle(obX, obY, obW, obH, -1, Type.Platform);  // If last platform had gravity direction 1, draw inverse this time
    else                          o = new Obstacle(obX, obY-obH, obW, obH, 1, Type.Platform);  // If last platform had gravity direction -1, draw normal this time
    obstacles.add(o);
  }
  
  lastPlatformLeft = obX;
  lastPlatformRight = obX + obW;
  if (screen == Screen.Invert) lastPlatformGravDir *= -1;
  strokeWeight(20);
}

public void updateObstacles() {
  java.util.Iterator<Obstacle> it = obstacles.iterator();
  while (it.hasNext()) {
    Obstacle o = it.next();
    if (o.offscreen()) it.remove( );
  }
}

public void drawObstacles() {
  for (Obstacle o : obstacles) o.draw();
}

public void updateCube() {
  
  cubeX += vx;
  
  prevY = cubeY;
  vy += -GRAVITY * gravDir;
  cubeY += vy;
  
  checkCollisions();
  
  if (screen == Screen.Normal && cubeY-CUBE_SIZE/2 <= 0) {
    land();
  }

  if (!onSurface) {
    // spin forward with normal gravity, spin backward with inverted 
    cubeAngle += ROTATE_PER_FRAME * gravDir;
  }
  else {
    cubeAngle = 0;
  }
  cubeAngle = cubeAngle % TWO_PI;  // keep cubeAngle in the range [0, TWO_PI)
  if (cubeAngle < 0) cubeAngle += TWO_PI;
  
}

public void checkCollisions() {

  float cubeLeft = cubeX - CUBE_SIZE/2;
  float cubeRight = cubeX + CUBE_SIZE/2;
  float cubeBottom = cubeY - CUBE_SIZE/2;
  float cubeTop = cubeY + CUBE_SIZE/2;

  for (Obstacle o : obstacles) {

    float oLeft = o.x;
    float oRight = o.x + o.w;
    float oBottom = o.y;
    float oTop = o.y + o.h;
    
    float overlapX = min(cubeRight, oRight) - max(cubeLeft, oLeft);
    float overlapY = min(cubeTop, oTop) - max(cubeBottom, oBottom);
      
    if (overlapX>0 && overlapY>0) {
      
      if (overlapX < overlapY) { // horizontal collision, fatal crash
      
        float overlapRight = cubeRight - oLeft;
        float overlapLeft = oRight - cubeLeft;
        
        if (overlapRight < overlapLeft) { // right collision, fatal crash. left collision is ignorable
          screen = Screen.Crash;
        }
      } 
      
      else { // vertical collision
      
        float overlapTop = cubeTop - oBottom;
        float overlapBottom = oTop - cubeBottom;
        
        // Collision with top of cube
        if (overlapTop < overlapBottom) { 
          if (screen == Screen.Invert && gravDir == -1) land(oBottom);          // Invert, gravDir = -1: land "upwards" on platform 
          else                                          screen = Screen.Crash;  // Normal || Invert, gravDir = 1: fatal crash                              
        }
        
        // Collision with bottom of cube
        else { // safely landed on surface of platform
          if (screen == Screen.Invert && gravDir == -1) screen = Screen.Crash;  // Invert, gravDir = -1: fatal crash
          else                                          land(oTop);             // Normal || Invert, gravDir = 1: land on platform
        }
      }
    }
  }
}

public void resetVariables(Screen s) {
  
  lastPlatformRight = 0;
  lastPlatformLeft = 0;
  lastPlatformGravDir = 1;

  groundX = 0;
  difficulty = 0;
  obstacles.clear();
  
  cubeX = CUBE_OFFSET + CUBE_SIZE/2;
  cubeY = CUBE_SIZE/2;
  vx = MOVE_SPEED;
  vy = 0;
  onSurface = true;
  gravDir = 1;
  
  cameraX = 0;
  cameraY = CUBE_SIZE/2;
  cameraSpeed = MOVE_SPEED;
  
  thisJumpX = 0;
  thisJumpY = 0; 
  thisLandX = cubeX;
  thisLandY = CUBE_SIZE/2; 

  nextJumpX = cubeX + SAFE_RANGE_W;
  nextJumpY = CUBE_SIZE/2;
  if (s == Screen.Normal) {

    float nextJumpMaxY = nextJumpY + JUMP_MIDPOINT_HEIGHT;
    
    nextLandY = random(0, nextJumpMaxY) - JUMP_LEEWAY;
    if (nextLandY < MIN_PLATFORM_H + CUBE_SIZE/2) nextLandY = CUBE_SIZE/2;
    nextLandX = landingXForTargetY(nextJumpX, nextJumpY, nextLandY);
  }
  else if (s == Screen.Invert) {
    float nextJumpYDiff = random(CUBE_SIZE*3, height-GROUND_HEIGHT);
    nextLandY = (lastPlatformGravDir == 1) ? nextJumpY+nextJumpYDiff : nextJumpY-nextJumpYDiff;
    nextLandX = landingXForTargetYInvert(nextJumpX, nextJumpY, nextLandY);

    // Add initial platform in place of ground permanent ground
    Obstacle o = new Obstacle(0, -height*5, SAFE_RANGE_W + CUBE_OFFSET + CUBE_SIZE/2, height*5, 1, Type.Platform);
    obstacles.add(o);
    
    lastPlatformRight = SAFE_RANGE_W + CUBE_OFFSET + CUBE_SIZE/2;
    lastPlatformLeft = 0;
  }
  
}

public void drawCube() {
  pushMatrix();
  pushStyle();

  translate(cubeX, cubeY);
  rotate(-cubeAngle);  // for clockwise rotation (note that this rotation doesn't affect the hitbox of the cube)
  rectMode(CENTER);
  
  stroke(0);
  strokeWeight(4);
  fill(255,255,0);
  rect(0, 0, CUBE_SIZE, CUBE_SIZE);

  popMatrix();
  popStyle();
}

public void updateGround() {
  groundX += cameraSpeed;
}

public void drawGround() {
  drawGround(0, GROUND_COLOR, width, GROUND_HEIGHT, 1);
}

public void drawGround(int stroke, int c, float w, float h, float dir) {
  pushMatrix(); pushStyle();
  scale(1,dir); // To draw upside down ground in invert gamemode
  strokeWeight(stroke);
  fill(c);
  rect(groundX,-h,w,h);
  
  // White separator line 
  strokeWeight(2);
  line(groundX,0,groundX+width,0);
  popMatrix(); popStyle();
}

public void jump() {
  onSurface = false;
  if (screen == Screen.Normal) vy = JUMP_STRENGTH * gravDir;
}

public void land() {
  land(0);
}

// Checks for gravity direction as well to determine whether to land "down" or "up"
public void land(float h) {
  onSurface = true;
  cubeY = (gravDir == 1) ? h + CUBE_SIZE/2 : h - CUBE_SIZE/2;
  vy = 0;

  // Snap rotation to nearest 90 degrees
  float snap = HALF_PI;
  cubeAngle = round(cubeAngle / snap) * snap;
}

public boolean inJump() {
  return prevY != cubeY;
}

// returns landX
// inputs: takeoff x, takeoff y, landing y
public float landingXForTargetY(float jumpX, float jumpY, float landY) {

  float v0 = JUMP_STRENGTH;
  float y0 = jumpY;
  float yT = landY;

  // discriminant to solve quadratic equation
  float d = v0 * v0 - 2 * GRAVITY * (yT - y0);
  if (d < 0) {
    // discriminant < 0 => no solution => unreachable target above apex 
    // clamp y to apex
    float apexY = y0 + (v0*v0) / (2*GRAVITY);
    yT = apexY;
    d = 0;
  }

  // solve for the greater root (at later half of jump)
  float landT = (v0 + sqrt(d)) / GRAVITY;
  float landX = jumpX + vx * landT;

  return landX;
}

// returns landX for invert mode
// inputs: gravity direction, takeoff x, takeoff y, landing y
public float landingXForTargetYInvert(float jumpX, float jumpY, float landY) {
  
  // In invert mode, initial vy = 0 (unlike normal mode where vy = JUMP_STRENGTH)
  float v0 = 0;
  float y0 = jumpY;
  float yT = landY;
  float g = GRAVITY * gravDir; // gravity with direction
  
  // Using kinematic equation: y = y0 + v0*t + 0.5*g*t^2
  // Solving for t: t^2 = 2*(yT - y0)/g
  
  float deltaY = yT - y0;
  
  // Check if the target is reachable
  if ((g > 0 && deltaY < 0) || (g < 0 && deltaY > 0)) {
    // Unreachable target - gravity pulls in wrong direction
    return jumpX; // Return starting position as fallback
  }
  
  // Calculate time to reach target
  float t_squared = 2 * deltaY / g;
  if (t_squared < 0) {
    return jumpX; // Fallback for invalid cases
  }
  
  float landT = sqrt(t_squared);
  float landX = jumpX + vx * landT;
  
  return landX;
}

public void keyPressed() {
  if (!pressedSpace) pressedSpace = true;
  if (screen == Screen.Normal) {
    keyPressedGame();
  }
  else if (screen == Screen.Invert) {
    keyPressedInvert();
  }
} 

public void mousePressed() {
  if (screen == Screen.Menu) {
    mousePressedMenu();
  } 
  else if (screen == Screen.Normal || screen == Screen.Invert) {
    mousePressedGame();
  }
  else if (screen == Screen.Crash) {
    mousePressedCrash();
  }
}
int[] layerColors = {
  color(75,0,119),
  color(127,19,189),
  color(173,83,225),
  color(177,111,219),
  color(179,131,204),
  color(199,149,230)
};

// {x, y, w, h} of all member rectangles in layer 
float[][] layer1 = {
  {0, 0, 349, 524},
  {349, 0, 262, 349},
  {611, 0, 314, 611},
  {925, 0, 349, 698},
  {1274, 0, 436, 489},
  {1710, 0, 210, 558}
};
float[][] layer2 = {
  {0, 0, 560, 810},
  {560, 0, 650, 516},
  {1210, 0, 710, 675}
};
float[][] layer3 = {
  {1348, 0, 180, 907}
};
float[][] layer4 = {
  {840, 690, 285, 246},
  {1018, 841, 221, 153}
};
float[][] layer5 = {
  {246, 858, 100, 100},
  {304, 821, 167, 92},
  {603, 535, 205, 76},
  {705, 440, 126, 221}
};
float[][] layer6 = {
  {0,0,1921,1080+GROUND_HEIGHT}
};
ArrayList<float[][]> layers = new ArrayList<>();  // Layers are added in ascending order of depth in setup()  



public void drawBackground() {
  
  pushMatrix(); pushStyle();

  // Make Processing treat (0,0) as bottom left, and make ground level 0
  translate(0, height);
  scale(1,-1);

  // Draw parallax layers 
  for (int layer=layers.size()-1; layer>=0; layer--) {

    int depth = layer+1;
    noStroke();
    fill(layerColors[layer]);

    for (float[] r : layers.get(layer)) {
      float x = r[0];
      float y = r[1];  
      float w = r[2];
      float h = r[3];
      drawParallaxObject(x, y, w, h, depth);
    }  
  }  
  
  popMatrix(); popStyle();
}

// Can only draw rectangular objects
// Draws two copies of the same object at camera step and step+1
public void drawParallaxObject(float x, float y, float w, float h, int depth) {
  int step = (int)cameraX / PApplet.parseInt(width*depth);
  int world_x = step*width*depth;
  int world_x2 = (step+1)*width*depth;
  float drawX1 = (world_x - cameraX) / depth;
  float drawX2 = (world_x2 - cameraX) / depth;
  rect(drawX1+x, y, w, h);
  rect(drawX2+x, y, w, h);
}
float CRASHED_TEXT_SIZE = 800;

float AGAIN_BUTTON_X = 770;
float MENU_BUTTON_X = 1150;

public void drawCrash() {
  pushMatrix();
  // Freeze cube
  vx = 0;
  vy = 0;

  // Slow camera to stop
  cameraSpeed *= 0.95f;  
  if (cameraSpeed < 0.1f) cameraSpeed = 0; 
  updateCamera();
  
  if (lastGame == Game.Invert) {
    pushMatrix();
    // draw background
    translate(0, GROUND_HEIGHT/2); // make the ground y=0
    drawBackground();
    popMatrix();
  }  
  else drawBackground();
  
  translate(0, height);
  scale(1,-1);
  pushMatrix();
  translate(-cameraX, -cameraY);
  if (lastGame == Game.Normal) translate(0, GROUND_HEIGHT);
  else if (lastGame == Game.Invert) translate(0, GROUND_HEIGHT/2);
  generateObstacles();
  updateObstacles();
  drawObstacles();
  //updateCube(); // stops all cube updates
  drawCube();
  if (lastGame == Game.Normal) {
    updateGround(); 
    drawGround();
  }
  popMatrix();
  
  // Draw red translucent foreground to dim background
  noStroke();
  fill(75, 0, 0, 200); 
  rectMode(CORNER);
  rect(0,0, width, height);
  
  updateScore();
  drawUI();
  
  pushMatrix(); pushStyle();
  translate(0, height);
  scale(1,-1);

  // "CRASHED" text
  textSize(TITLE_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(100,0,0);
  text("C R A S H E D", width/2, height/2);
  
  // "again" button
  fill(0,0,0,120);
  rectMode(CENTER);
  rect(AGAIN_BUTTON_X, height/2, BUTTON_W, BUTTON_H);

  textSize(BUTTON_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(255,255,255);
  text("again", AGAIN_BUTTON_X, height/2);
  
  // "menu" button
  fill(0,0,0,120);
  rectMode(CENTER);
  rect(MENU_BUTTON_X, height/2, BUTTON_W, BUTTON_H);

  textSize(BUTTON_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(255,255,255);
  text("menu", MENU_BUTTON_X, height/2);
  
  highlightCrashButtons();
  
  popMatrix(); popStyle();
  popMatrix();
}

// Called by mousePressed, handles mouse presses in the menu
public void mousePressedCrash() {
  
  // Check if mouse is on AGAIN button
  if (mouseX > AGAIN_BUTTON_X - BUTTON_W/2 && mouseX < AGAIN_BUTTON_X + BUTTON_W/2 && 
      mouseY > height/2 - BUTTON_H/2 && mouseY < height/2 + BUTTON_H/2) {
    
    // Start Normal game or Invert game
    if (lastGame == Game.Normal) {
      resetVariables(Screen.Normal);
      screen = Screen.Normal;
    }
    else if (lastGame == Game.Invert) {
      resetVariables(Screen.Invert);
      screen = Screen.Invert;
    }
  }
  
  // Check if mouse is on MENU button  
  if (mouseX > MENU_BUTTON_X - BUTTON_W/2 && mouseX < MENU_BUTTON_X + BUTTON_W/2 && 
      mouseY > height/2 - BUTTON_H/2 && mouseY < height/2 + BUTTON_H/2) {

    screen = Screen.Menu;
  }
}

public void highlightCrashButtons() {
  // Check if mouse is on AGAIN button
  if (mouseX > AGAIN_BUTTON_X - BUTTON_W/2 && mouseX < AGAIN_BUTTON_X + BUTTON_W/2 && 
      mouseY > height/2 - BUTTON_H/2 && mouseY < height/2 + BUTTON_H/2) {
    
    // Darker "AGAIN" button
    fill(0,0,0);
    rectMode(CENTER);
    rect(AGAIN_BUTTON_X, height/2, BUTTON_W, BUTTON_H);
  
    textSize(BUTTON_TEXT_SIZE);
    textAlign(CENTER, CENTER);
    fill(255,255,255);
    text("AGAIN", AGAIN_BUTTON_X, height/2);
  }
  
  // Check if mouse is on MENU button  
  if (mouseX > MENU_BUTTON_X - BUTTON_W/2 && mouseX < MENU_BUTTON_X + BUTTON_W/2 && 
      mouseY > height/2 - BUTTON_H/2 && mouseY < height/2 + BUTTON_H/2) {
    
    // Darker "MENU" button
    fill(0,0,0);
    rectMode(CENTER);
    rect(MENU_BUTTON_X, height/2, BUTTON_W, BUTTON_H);
  
    textSize(BUTTON_TEXT_SIZE);
    textAlign(CENTER, CENTER);
    fill(255,255,255);
    text("MENU", MENU_BUTTON_X, height/2);
  }
}
public void drawInvertGame() {
  pushMatrix();
  
  // update camera 
  updateCamera();
  
  pushMatrix();
  // draw background
  translate(0, GROUND_HEIGHT/2); // make the ground y=0
  drawBackground();
  popMatrix();
  
  // Make Processing treat (0,0) as bottom left, and make ground level 0
  translate(0, height);
  scale(1,-1);
  pushMatrix();
  
  // move camera (before drawing the foreground)
  translate(-cameraX, -cameraY);
  translate(0, GROUND_HEIGHT/2); // make the ground y=0

  // procedural generation: spawn, update, draw obstacles
  generateObstacles();
  updateObstacles();
  drawObstacles();
  
  updateCube();
  drawCube();

  // reset transformation matrix 
  popMatrix();
  
  // update score 
  updateScore();
  
  // draw UI
  drawUI();
  
  popMatrix();
}

public void keyPressedInvert() {
  if (key == ' ' && onSurface && !inJump()) {
    gravDir *= -1;
    jump();
  } 
}
float BUTTON_W = 350;
float BUTTON_H = 100;
float BUTTON_TEXT_SIZE = 75;

float TITLE_TEXT_Y = 370;
float HIGHSCORE_TEXT_Y = 550;
float NORMAL_BUTTON_Y = 660;
float INVERT_BUTTON_Y = 790;

float TITLE_TEXT_SIZE = 400;
float HIGHSCORE_TEXT_SIZE = 50;

float MENU_BACKGROUND_SPEED_MULTIPLIER = 0.5f;

float menuFrame = 0;
String[] titleSeq = {
  "evrdsh"//,
  //"Evrdsh",
  //"eVrdsh",
  //"evRdsh",
  //"evrDsh",
  //"evrdSh",
  //"evrdsH"
};

public void drawMenu() {
  pushMatrix();
  pushStyle();

  // Draw parallax background moving slower than in-game
  cameraX += MOVE_SPEED * MENU_BACKGROUND_SPEED_MULTIPLIER;
  pushMatrix(); pushStyle();
  translate(0,GROUND_HEIGHT);
  drawBackground();
  popMatrix(); popStyle();
  
  // Draw translucent foreground to dim background
  fill(0, 0, 0, 120); 
  rectMode(CORNER);
  rect(0,0, width, height);

  // Draw title and buttons
  // Title
  //textSize(TITLE_TEXT_SIZE);
  //textAlign(CENTER, CENTER);
  //fill(207, 255, 4);
  //text("evrdsh", width/2, TITLE_TEXT_Y);
  drawTitle();
  
  // "HIGHSCORE"
  textSize(HIGHSCORE_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(255,255,255);
  text("HIGHSCORE          " + normalHighscore + "          " + invertHighscore, width/2, HIGHSCORE_TEXT_Y);

  // "normal" button
  fill(0,0,0,120);
  rectMode(CENTER);
  rect(width/2, NORMAL_BUTTON_Y, BUTTON_W, BUTTON_H);
  
  // "normal" text
  textSize(BUTTON_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(255,255,255);
  text("normal", width/2, NORMAL_BUTTON_Y);

  // "invert" button
  fill(0,0,0,120);
  rectMode(CENTER);
  rect(width/2, INVERT_BUTTON_Y, BUTTON_W, BUTTON_H);

  // "invert" text
  textSize(BUTTON_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(255,255,255);
  text("invert", width/2, INVERT_BUTTON_Y);

  highlightMenuButtons(); 

  popMatrix();
  popStyle();
}

public void drawTitle() {
  // Calculate which title to show based on menuFrame
  int titleIndex = (int)(menuFrame / 20  ) % titleSeq.length;
  String currentTitle = titleSeq[titleIndex];
  
  // Draw the animated title
  textSize(TITLE_TEXT_SIZE);
  textAlign(CENTER, CENTER);
  fill(207, 255, 4);
  text(currentTitle, width/2, TITLE_TEXT_Y);
  
  // Increment frame counter
  menuFrame++;
}

// Called by mousePressed, handles mouse presses in the menu
public void mousePressedMenu() {
  
  // Check if mouse is on Normal button
  if (mouseX > width/2 - BUTTON_W/2 && mouseX < width/2 + BUTTON_W/2 && 
      mouseY > NORMAL_BUTTON_Y - BUTTON_H/2 && mouseY < NORMAL_BUTTON_Y + BUTTON_H/2) {
    
    // Start Normal game
    resetVariables(Screen.Normal);
    lastGame = Game.Normal;
    screen = Screen.Normal;
  }
  
  // Check if mouse is on Invert button  
  if (mouseX > width/2 - BUTTON_W/2 && mouseX < width/2 + BUTTON_W/2 && 
      mouseY > INVERT_BUTTON_Y - BUTTON_H/2 && mouseY < INVERT_BUTTON_Y + BUTTON_H/2) {
    
    // Start Invert game
    resetVariables(Screen.Invert);
    lastGame = Game.Invert;
    screen = Screen.Invert;
  }
}

public void highlightMenuButtons() {
  // Check if mouse is on Normal button
  if (mouseX > width/2 - BUTTON_W/2 && mouseX < width/2 + BUTTON_W/2 && 
      mouseY > NORMAL_BUTTON_Y - BUTTON_H/2 && mouseY < NORMAL_BUTTON_Y + BUTTON_H/2) {
    
    // Darker "invert" button
    fill(0,0,0);
    rectMode(CENTER);
    rect(width/2, NORMAL_BUTTON_Y, BUTTON_W, BUTTON_H);
  
    // "normal" text
    textSize(BUTTON_TEXT_SIZE);
    textAlign(CENTER, CENTER);
    fill(255,255,255);
    text("NORMAL", width/2, NORMAL_BUTTON_Y);
  }
  
  // Check if mouse is on Invert button  
  if (mouseX > width/2 - BUTTON_W/2 && mouseX < width/2 + BUTTON_W/2 && 
      mouseY > INVERT_BUTTON_Y - BUTTON_H/2 && mouseY < INVERT_BUTTON_Y + BUTTON_H/2) {
    
    // Darker "invert" button
    fill(0,0,0);
    rectMode(CENTER);
    rect(width/2, INVERT_BUTTON_Y, BUTTON_W, BUTTON_H);
  
    // "invert" text
    textSize(BUTTON_TEXT_SIZE);
    textAlign(CENTER, CENTER);
    fill(255,255,255);
    text("INVERT", width/2, INVERT_BUTTON_Y);
  }
}
public void drawNormalGame() {
  pushMatrix();
  // update camera 
  updateCamera();
  
  // draw background
  drawBackground();
  
  // Make Processing treat (0,0) as bottom left, and make ground level 0
  translate(0, height);
  scale(1,-1);
  pushMatrix();
  
  // move camera (before drawing the foreground)
  translate(-cameraX, -cameraY);
  translate(0, GROUND_HEIGHT); // make the ground y=0

  // procedural generation: spawn, update, draw obstacles
  generateObstacles();
  updateObstacles();
  drawObstacles();
  
  updateCube();
  drawCube();
  
  updateGround();
  drawGround();


  // reset transformation matrix 
  popMatrix();
  
  // update score 
  updateScore();
  
  // draw UI
  drawUI();
  popMatrix();
}

public void mousePressedGame() {
  
}

public void keyPressedGame() {
  if (key == ' ' && onSurface && !inJump()) {
    jump();
  } 
}
enum Type {Platform}

class Obstacle {
  float x, y, w, h, grav;
  Type type;
  
  Obstacle(float x, float y, float w, float h, float grav, Type type) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.grav = grav;
    this.type = type;
  }

  public void draw() {
    fill(OBSTACLE_COLOR);
    strokeWeight(1);
    stroke(OBSTACLE_OUTLINE_COLOR);
    rect(x, y, w, h);
  }

  public boolean offscreen() {
    return x + w < cameraX - OBSTACLE_UPDATE_OFFSET;
  }
  
  public String toString() {
    return "x: " + this.x + ", y: " + this.y + ", w: " + this.w + ", h: " + this.h + ", yLand: " + ((this.grav == 1) ? this.y+this.h+CUBE_SIZE/2 : this.y-CUBE_SIZE/2) + ", grav: " + this.grav;
  }
}


  public void settings() { size(1920, 1080); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "evrdsh" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
